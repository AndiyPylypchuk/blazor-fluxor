using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace Blazor.Fluxor
{
	public class Store : IStore
	{
		public IEnumerable<IFeature> Features => FeaturesByName.Values;

		private readonly Dictionary<string, IFeature> FeaturesByName = new Dictionary<string, IFeature>(StringComparer.InvariantCultureIgnoreCase);
		private readonly Dictionary<Type, List<IEffect>> EffectsByActionType = new Dictionary<Type, List<IEffect>>();
		private readonly List<IStoreMiddleware> Middlewares = new List<IStoreMiddleware>();

		public void AddFeature(IFeature feature)
		{
			if (feature == null)
				throw new ArgumentNullException(nameof(feature));
			FeaturesByName.Add(feature.GetName(), feature);
		}

		public async Task Dispatch<TAction>(TAction action)
			where TAction : IAction
		{
			if (action == null)
				throw new ArgumentNullException(nameof(action));

			var actionsToDispatch = new Queue<IAction>();
			actionsToDispatch.Enqueue(action);

			while (actionsToDispatch.Any())
			{
				IAction currentActionToDispatch = actionsToDispatch.Dequeue();

				ExecuteMiddlewareBeforeDispatch(currentActionToDispatch);

				// Notify all features of this action
				foreach(var featureInstance in FeaturesByName.Values)
				{
					NotifyFeatureOfDispatch(featureInstance, currentActionToDispatch);
				};

				ExecuteMiddlewareAfterDispatch(currentActionToDispatch);

				// Get any actions generated by side-effects
				IEnumerable <IAction> actionsCreatedBySideEffects = await TriggerEffects(currentActionToDispatch);
				foreach (IAction actionFromSideEffect in actionsCreatedBySideEffects)
					actionsToDispatch.Enqueue(actionFromSideEffect);
			}
		}


		public void AddEffect(Type actionType, IEffect effect)
		{
			if (actionType == null)
				throw new ArgumentNullException(nameof(actionType));
			if (effect == null)
				throw new ArgumentNullException(nameof(effect));

			Type genericType = typeof(IEffect<>).MakeGenericType(actionType);
			if (!genericType.IsAssignableFrom(effect.GetType()))
				throw new ArgumentException($"Effect {effect.GetType().Name} does not implement IEffect<{actionType.Name}>");

			List<IEffect> effects = GetEffectsForActionType(actionType, true);
			effects.Add(effect);
		}

		public void AddMiddleware(IStoreMiddleware middleware)
		{
			Middlewares.Add(middleware);
			middleware.Initialize(this);
		}

		private List<IEffect> GetEffectsForActionType(Type actionType, bool createIfNonExistent)
		{
			EffectsByActionType.TryGetValue(actionType, out List<IEffect> effects);
			if (createIfNonExistent && effects == null)
			{
				effects = new List<IEffect>();
				EffectsByActionType[actionType] = effects;
			}
			return effects;
		}

		private async Task<IEnumerable<IAction>> TriggerEffects(IAction action)
		{
			var allActionsCreatedByAllSideEffects = new List<IAction>();

			IEnumerable<IEffect> effectsForAction = GetEffectsForActionType(action.GetType(), false);
			if (effectsForAction != null && effectsForAction.Any())
			{
				foreach (var effect in effectsForAction)
				{
					IAction[] actionsFromSideEffect = await effect.Handle(action);
					if (actionsFromSideEffect != null)
					{
						foreach(IAction actionFromSideEffect in actionsFromSideEffect)
						{
							if (actionFromSideEffect != null)
								allActionsCreatedByAllSideEffects.Add(actionFromSideEffect);
						}
					}
				}
			}

			return allActionsCreatedByAllSideEffects;
		}

		private void ExecuteMiddlewareBeforeDispatch(IAction actionAboutToExecute)
		{
			foreach (IStoreMiddleware middleWare in Middlewares)
				ExecuteMiddlewareActionMethod(middleWare, nameof(IStoreMiddleware.BeforeDispatch), actionAboutToExecute);
		}

		private void ExecuteMiddlewareAfterDispatch(IAction actionExecuted)
		{
			foreach (IStoreMiddleware middleWare in Middlewares)
				ExecuteMiddlewareActionMethod(middleWare, nameof(IStoreMiddleware. AfterDispatch), actionExecuted);
		}

		private void NotifyFeatureOfDispatch(IFeature feature, IAction action)
		{
			string methodName = nameof(IFeature.ReceiveDispatchNotificationFromStore);
			// We need the generic method for the feature instance
			MethodInfo methodInfo = feature
				.GetType()
				.GetMethod(methodName)
				.MakeGenericMethod(action.GetType());

			methodInfo.Invoke(feature, new object[] { action });
		}

		private void ExecuteMiddlewareActionMethod(IStoreMiddleware middleware, string methodName, IAction action)
		{
			// We need the generic method for the feature instance
			MethodInfo methodInfo = middleware
				.GetType()
				.GetMethod(methodName)
				.MakeGenericMethod(action.GetType());

			methodInfo.Invoke(middleware, new object[] { this, action });
		}

	}
}
